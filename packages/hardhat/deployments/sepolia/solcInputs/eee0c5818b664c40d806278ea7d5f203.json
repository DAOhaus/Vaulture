{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.18;\n\ninterface IBaseStrategy {\n\tfunction tokenizedStrategyAddress() external view returns (address);\n\n\t/*//////////////////////////////////////////////////////////////\n                            IMMUTABLE FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n\tfunction availableDepositLimit(\n\t\taddress _owner\n\t) external view returns (uint256);\n\n\tfunction availableWithdrawLimit(\n\t\taddress _owner\n\t) external view returns (uint256);\n\n\tfunction deployFunds(uint256 _assets) external;\n\n\tfunction freeFunds(uint256 _amount) external;\n\n\tfunction harvestAndReport() external returns (uint256);\n\n\tfunction tendThis(uint256 _totalIdle) external;\n\n\tfunction shutdownWithdraw(uint256 _amount) external;\n\n\tfunction tendTrigger() external view returns (bool, bytes memory);\n}\n"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.18;\n\ninterface IFactory {\n\tfunction protocol_fee_config() external view returns (uint16, address);\n}\n"
    },
    "contracts/TokenizedStrategy.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.18;\n\n/**$$$$$$$$$$$$$$$$$$$$$$$$$$$&Mr/|1+~>>iiiiiiiiiii>~+{|tuMW$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$B#j]->iiiiiiiiiiiiiiiiiiiiiiiiiiii>-?f*B$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$@zj}~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~}fv@$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$@z(+iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii+)zB$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$Mf~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~t#@$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$@u[iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?n@$$$$$$$$$$$$$\n$$$$$$$$$$$@z]iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii?u@$$$$$$$$$$$\n$$$$$$$$$$v]iiiiiiiiiiiiiiii,.';iiiiiiiiiiiiiiiiiiiiiiiiii;'.\"iiiiiiiiiiiiiiii?u$$$$$$$$$$\n$$$$$$$$%)>iiiiiiiiiiiiiii,.    ';iiiiiiiiiiiiiiiiiiiiii;'    .\"iiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$c~iiiiiiiiiiiiiii,.        ';iiiiiiiiiiiiiiiiii;'        .\"iiiiiiiiiiiiiii~u$$$$$$$\n$$$$$B/>iiiiiiiiiiiiii!'            `IiiiiiiiiiiiiiiI`            .Iiiiiiiiiiiiiii>|%$$$$$\n$$$$@)iiiiiiiiiiiiiiiii;'             `Iiiiiiiiiiil`             ';iiiiiiiiiiiiiiiii}@$$$$\n$$$B|iiiiiiiiiiiiiiiiiiii;'             `Iiiiiiil`             ';iiiiiiiiiiiiiiiiiiii1B$$$\n$$@)iiiiiiiiiiiiiiiiiiiiiii:'             `;iiI`             ':iiiiiiiiiiiiiiiiiiiiiii{B$$\n$$|iiiiiiiiiiiiiiiiiiiiiiiiii;'             ``             ':iiiiiiiiiiiiiiiiiiiiiiiiii1$$\n$v>iiiiiiiiiiiiiiiiiiiiiiiiiiii:'                        ':iiiiiiiiiiiiiiiiiiiiiiiiiiii>x$\n&?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                    .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-W\nziiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'                .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiv\n-iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii:'            .,iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-\n<iiiiiiiiiiiiiiiiiiii!.':iiiiiiiiiiiiii,          \"iiiiiiiiiiiiii;'.Iiiiiiiiiiiiiiiiiiiii<\niiiiiiiiiiiiiiiiiiiii'   ';iiiiiiiiiiiii          Iiiiiiiiiiiii;'   .iiiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii,      ';iiiiiiiiiii          IiiiiiiiiiiI`      `iiiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiiii.        `Iiiiiiiiii          Iiiiiiiii!`         !iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii;          :iiiiiiiii          Iiiiiiiii!          ,iiiiiiiiiiiiiiiiiii\niiiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii.         ^iiiiiiiiiiiiiiiiiii\n<iiiiiiiiiiiiiiiiii,          iiiiiiiiii          Iiiiiiiiii'         ^iiiiiiiiiiiiiiiiii<\n-iiiiiiiiiiiiiiiiii;          Iiiiiiiiii          Iiiiiiiiii.         \"iiiiiiiiiiiiiiiiii-\nziiiiiiiiiiiiiiiiiii.         'iiiiiiiii''''''''''liiiiiiii^          liiiiiiiiiiiiiiiiiiv\n&?iiiiiiiiiiiiiiiiii^          ^iiiiiiiiiiiiiiiiiiiiiiiiii,          `iiiiiiiiiiiiiiiiii_W\n$u>iiiiiiiiiiiiiiiiii.          `!iiiiiiiiiiiiiiiiiiiiiii^          .liiiiiiiiiiiiiiiiiir$\n$$(iiiiiiiiiiiiiiiiii;.          .\"iiiiiiiiiiiiiiiiiiii,.           :iiiiiiiiiiiiiiiiii}$$\n$$@{iiiiiiiiiiiiiiiiii;.           .`:iiiiiiiiiiiiii;^.            :iiiiiiiiiiiiiiiiii}B$$\n$$$B)iiiiiiiiiiiiiiiiii!'              '`\",::::,\"`'.             .Iiiiiiiiiiiiiiiiiii{%$$$\n$$$$@1iiiiiiiiiiiiiiiiiii,.                                     ^iiiiiiiiiiiiiiiiiii[@$$$$\n$$$$$B|>iiiiiiiiiiiiiiiiii!^.                                 `liiiiiiiiiiiiiiiiii>)%$$$$$\n$$$$$$$c~iiiiiiiiiiiiiiiiiiii\"'                            .\"!iiiiiiiiiiiiiiiiiii~n$$$$$$$\n$$$$$$$$B)iiiiiiiiiiiiiiiiiiiii!,`.                    .'\"liiiiiiiiiiiiiiiiiiiii1%$$$$$$$$\n$$$$$$$$$@u]iiiiiiiiiiiiiiiiiiiiiiil,^`'..      ..''^,liiiiiiiiiiiiiiiiiiiiiii-x@$$$$$$$$$\n$$$$$$$$$$$@v?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-x$$$$$$$$$$$$\n$$$$$$$$$$$$$@n?iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii-rB$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$/~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<\\*@$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$Bc1~iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii~{v%$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$Bvf]<iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii<]tuB$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$%zt-+>iiiiiiiiiiiiiiiiiiiiiiiiiiiii+_tc%$$$$$$$$$$$$$$$$$$$$$$$$$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$W#u/|{+~>iiiiiiiiiiii><+{|/n#W$$$$$$$$$$$$$$$$$$$$$$$$$$$$*/\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { IFactory } from \"./interfaces/IFactory.sol\";\nimport { IBaseStrategy } from \"./interfaces/IBaseStrategy.sol\";\n\n/**\n * @title Yearn Tokenized Strategy\n * @author yearn.finance\n * @notice\n *  This TokenizedStrategy can be used by anyone wishing to easily build\n *  and deploy their own custom ERC4626 compliant single strategy Vault.\n *\n *  The TokenizedStrategy contract is meant to be used as the proxy\n *  implementation contract that will handle all logic, storage and\n *  management for a custom strategy that inherits the `BaseStrategy`.\n *  Any function calls to the strategy that are not defined within that\n *  strategy will be forwarded through a delegateCall to this contract.\n\n *  A strategist only needs to override a few simple functions that are\n *  focused entirely on the strategy specific needs to easily and cheaply\n *  deploy their own permissionless 4626 compliant vault.\n */\ncontract TokenizedStrategy {\n\tusing Math for uint256;\n\tusing SafeERC20 for ERC20;\n\n\t/*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\t/**\n\t * @notice Emitted when a strategy is shutdown.\n\t */\n\tevent StrategyShutdown();\n\n\t/**\n\t * @notice Emitted on the initialization of any new `strategy` that uses `asset`\n\t * with this specific `apiVersion`.\n\t */\n\tevent NewTokenizedStrategy(\n\t\taddress indexed strategy,\n\t\taddress indexed asset,\n\t\tstring apiVersion\n\t);\n\n\t/**\n\t * @notice Emitted when the strategy reports `profit` or `loss` and\n\t * `performanceFees` and `protocolFees` are paid out.\n\t */\n\tevent Reported(\n\t\tuint256 profit,\n\t\tuint256 loss,\n\t\tuint256 protocolFees,\n\t\tuint256 performanceFees\n\t);\n\n\t/**\n\t * @notice Emitted when the 'performanceFeeRecipient' address is\n\t * updated to 'newPerformanceFeeRecipient'.\n\t */\n\tevent UpdatePerformanceFeeRecipient(\n\t\taddress indexed newPerformanceFeeRecipient\n\t);\n\n\t/**\n\t * @notice Emitted when the 'keeper' address is updated to 'newKeeper'.\n\t */\n\tevent UpdateKeeper(address indexed newKeeper);\n\n\t/**\n\t * @notice Emitted when the 'performanceFee' is updated to 'newPerformanceFee'.\n\t */\n\tevent UpdatePerformanceFee(uint16 newPerformanceFee);\n\n\t/**\n\t * @notice Emitted when the 'management' address is updated to 'newManagement'.\n\t */\n\tevent UpdateManagement(address indexed newManagement);\n\n\t/**\n\t * @notice Emitted when the 'emergencyAdmin' address is updated to 'newEmergencyAdmin'.\n\t */\n\tevent UpdateEmergencyAdmin(address indexed newEmergencyAdmin);\n\n\t/**\n\t * @notice Emitted when the 'profitMaxUnlockTime' is updated to 'newProfitMaxUnlockTime'.\n\t */\n\tevent UpdateProfitMaxUnlockTime(uint256 newProfitMaxUnlockTime);\n\n\t/**\n\t * @notice Emitted when the 'pendingManagement' address is updated to 'newPendingManagement'.\n\t */\n\tevent UpdatePendingManagement(address indexed newPendingManagement);\n\n\t/**\n\t * @notice Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(\n\t\taddress indexed owner,\n\t\taddress indexed spender,\n\t\tuint256 value\n\t);\n\n\t/**\n\t * @notice Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @notice Emitted when the `caller` has exchanged `assets` for `shares`,\n\t * and transferred those `shares` to `owner`.\n\t */\n\tevent Deposit(\n\t\taddress indexed caller,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\t/**\n\t * @notice Emitted when the `caller` has exchanged `owner`s `shares` for `assets`,\n\t * and transferred those `assets` to `receiver`.\n\t */\n\tevent Withdraw(\n\t\taddress indexed caller,\n\t\taddress indexed receiver,\n\t\taddress indexed owner,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t);\n\n\t/*//////////////////////////////////////////////////////////////\n                        STORAGE STRUCT\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev The struct that will hold all the storage data for each strategy\n\t * that uses this implementation.\n\t *\n\t * This replaces all state variables for a traditional contract. This\n\t * full struct will be initialized on the creation of the strategy\n\t * and continually updated and read from for the life of the contract.\n\t *\n\t * We combine all the variables into one struct to limit the amount of\n\t * times the custom storage slots need to be loaded during complex functions.\n\t *\n\t * Loading the corresponding storage slot for the struct does not\n\t * load any of the contents of the struct into memory. So the size\n\t * will not increase memory related gas usage.\n\t */\n\t// prettier-ignore\n\tstruct StrategyData {\n        // The ERC20 compliant underlying asset that will be\n        // used by the Strategy\n        ERC20 asset;\n\n\n        // These are the corresponding ERC20 variables needed for the\n        // strategies token that is issued and burned on each deposit or withdraw.\n        uint8 decimals; // The amount of decimals that `asset` and strategy use.\n        uint88 INITIAL_CHAIN_ID; // The initial chain id when the strategy was created.\n        string name; // The name of the token for the strategy.\n        uint256 totalSupply; // The total amount of shares currently issued.\n        bytes32 INITIAL_DOMAIN_SEPARATOR; // The domain separator used for permits on the initial chain.\n        mapping(address => uint256) nonces; // Mapping of nonces used for permit functions.\n        mapping(address => uint256) balances; // Mapping to track current balances for each account that holds shares.\n        mapping(address => mapping(address => uint256)) allowances; // Mapping to track the allowances for the strategies shares.\n\n\n        // We manually track `totalAssets` to prevent PPS manipulation through airdrops.\n        uint256 totalAssets;\n\n\n        // Variables for profit reporting and locking.\n        // We use uint96 for timestamps to fit in the same slot as an address. That overflows in 2.5e+21 years.\n        // I know Yearn moves slowly but surely V4 will be out by then.\n        // If the timestamps ever overflow tell the cyborgs still using this code I'm sorry for being cheap.\n        uint256 profitUnlockingRate; // The rate at which locked profit is unlocking.\n        uint96 fullProfitUnlockDate; // The timestamp at which all locked shares will unlock.\n        address keeper; // Address given permission to call {report} and {tend}.\n        uint32 profitMaxUnlockTime; // The amount of seconds that the reported profit unlocks over.\n        uint16 performanceFee; // The percent in basis points of profit that is charged as a fee.\n        address performanceFeeRecipient; // The address to pay the `performanceFee` to.\n        uint96 lastReport; // The last time a {report} was called.\n\n\n        // Access management variables.\n        address management; // Main address that can set all configurable variables.\n        address pendingManagement; // Address that is pending to take over `management`.\n        address emergencyAdmin; // Address to act in emergencies as well as `management`.\n\n        // Strategy Status\n        uint8 entered; // To prevent reentrancy. Use uint8 for gas savings.\n        bool shutdown; // Bool that can be used to stop deposits into the strategy.\n    }\n\n\t/*//////////////////////////////////////////////////////////////\n                            MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev Require that the call is coming from the strategies management.\n\t */\n\tmodifier onlyManagement() {\n\t\trequireManagement(msg.sender);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Require that the call is coming from either the strategies\n\t * management or the keeper.\n\t */\n\tmodifier onlyKeepers() {\n\t\trequireKeeperOrManagement(msg.sender);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Require that the call is coming from either the strategies\n\t * management or the emergencyAdmin.\n\t */\n\tmodifier onlyEmergencyAuthorized() {\n\t\trequireEmergencyAuthorized(msg.sender);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Prevents a contract from calling itself, directly or indirectly.\n\t * Placed over all state changing functions for increased safety.\n\t */\n\tmodifier nonReentrant() {\n\t\tStrategyData storage S = _strategyStorage();\n\t\t// On the first call to nonReentrant, `entered` will be false (2)\n\t\trequire(S.entered != ENTERED, \"ReentrancyGuard: reentrant call\");\n\n\t\t// Any calls to nonReentrant after this point will fail\n\t\tS.entered = ENTERED;\n\n\t\t_;\n\n\t\t// Reset to false (1) once call has finished.\n\t\tS.entered = NOT_ENTERED;\n\t}\n\n\t/**\n\t * @notice Require a caller is `management`.\n\t * @dev Is left public so that it can be used by the Strategy.\n\t *\n\t * When the Strategy calls this the msg.sender would be the\n\t * address of the strategy so we need to specify the sender.\n\t *\n\t * @param _sender The original msg.sender.\n\t */\n\tfunction requireManagement(address _sender) public view {\n\t\trequire(_sender == _strategyStorage().management, \"!management\");\n\t}\n\n\t/**\n\t * @notice Require a caller is the `keeper` or `management`.\n\t * @dev Is left public so that it can be used by the Strategy.\n\t *\n\t * When the Strategy calls this the msg.sender would be the\n\t * address of the strategy so we need to specify the sender.\n\t *\n\t * @param _sender The original msg.sender.\n\t */\n\tfunction requireKeeperOrManagement(address _sender) public view {\n\t\tStrategyData storage S = _strategyStorage();\n\t\trequire(_sender == S.keeper || _sender == S.management, \"!keeper\");\n\t}\n\n\t/**\n\t * @notice Require a caller is the `management` or `emergencyAdmin`.\n\t * @dev Is left public so that it can be used by the Strategy.\n\t *\n\t * When the Strategy calls this the msg.sender would be the\n\t * address of the strategy so we need to specify the sender.\n\t *\n\t * @param _sender The original msg.sender.\n\t */\n\tfunction requireEmergencyAuthorized(address _sender) public view {\n\t\tStrategyData storage S = _strategyStorage();\n\t\trequire(\n\t\t\t_sender == S.emergencyAdmin || _sender == S.management,\n\t\t\t\"!emergency authorized\"\n\t\t);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n\t/// @notice API version this TokenizedStrategy implements.\n\tstring internal constant API_VERSION = \"3.0.2\";\n\n\t/// @notice Value to set the `entered` flag to during a call.\n\tuint8 internal constant ENTERED = 2;\n\t/// @notice Value to set the `entered` flag to at the end of the call.\n\tuint8 internal constant NOT_ENTERED = 1;\n\n\t/// @notice Maximum in Basis Points the Performance Fee can be set to.\n\tuint16 public constant MAX_FEE = 5_000; // 50%\n\n\t/// @notice Used for fee calculations.\n\tuint256 internal constant MAX_BPS = 10_000;\n\t/// @notice Used for profit unlocking rate calculations.\n\tuint256 internal constant MAX_BPS_EXTENDED = 1_000_000_000_000;\n\n\t/// @notice Seconds per year for max profit unlocking time.\n\tuint256 internal constant SECONDS_PER_YEAR = 31_556_952; // 365.2425 days\n\n\t/**\n\t * @dev Custom storage slot that will be used to store the\n\t * `StrategyData` struct that holds each strategies\n\t * specific storage variables.\n\t *\n\t * Any storage updates done by the TokenizedStrategy actually update\n\t * the storage of the calling contract. This variable points\n\t * to the specific location that will be used to store the\n\t * struct that holds all that data.\n\t *\n\t * We use a custom string in order to get a random\n\t * storage slot that will allow for strategists to use any\n\t * amount of storage in their strategy without worrying\n\t * about collisions.\n\t */\n\tbytes32 internal constant BASE_STRATEGY_STORAGE =\n\t\tbytes32(uint256(keccak256(\"yearn.base.strategy.storage\")) - 1);\n\n\t/*//////////////////////////////////////////////////////////////\n                               IMMUTABLE\n    //////////////////////////////////////////////////////////////*/\n\n\t/// @notice Address of the previously deployed Vault factory that the\n\t// protocol fee config is retrieved from.\n\taddress public immutable FACTORY;\n\n\t/*//////////////////////////////////////////////////////////////\n                            STORAGE GETTER\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev will return the actual storage slot where the strategy\n\t * specific `StrategyData` struct is stored for both read\n\t * and write operations.\n\t *\n\t * This loads just the slot location, not the full struct\n\t * so it can be used in a gas efficient manner.\n\t */\n\tfunction _strategyStorage() internal pure returns (StrategyData storage S) {\n\t\t// Since STORAGE_SLOT is a constant, we have to put a variable\n\t\t// on the stack to access it from an inline assembly block.\n\t\tbytes32 slot = BASE_STRATEGY_STORAGE;\n\t\tassembly {\n\t\t\tS.slot := slot\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                          INITIALIZATION\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Used to initialize storage for a newly deployed strategy.\n\t * @dev This should be called atomically whenever a new strategy is\n\t * deployed and can only be called once for each strategy.\n\t *\n\t * This will set all the default storage that must be set for a\n\t * strategy to function. Any changes can be made post deployment\n\t * through external calls from `management`.\n\t *\n\t * The function will also emit an event that off chain indexers can\n\t * look for to track any new deployments using this TokenizedStrategy.\n\t *\n\t * @param _asset Address of the underlying asset.\n\t * @param _name Name the strategy will use.\n\t * @param _management Address to set as the strategies `management`.\n\t * @param _performanceFeeRecipient Address to receive performance fees.\n\t * @param _keeper Address to set as strategies `keeper`.\n\t */\n\tfunction initialize(\n\t\taddress _asset,\n\t\tstring memory _name,\n\t\taddress _management,\n\t\taddress _performanceFeeRecipient,\n\t\taddress _keeper\n\t) external {\n\t\t// Cache storage pointer.\n\t\tStrategyData storage S = _strategyStorage();\n\n\t\t// Make sure we aren't initialized.\n\t\trequire(address(S.asset) == address(0), \"initialized\");\n\n\t\t// Set the strategy's underlying asset.\n\t\tS.asset = ERC20(_asset);\n\t\t// Set the Strategy Tokens name.\n\t\tS.name = _name;\n\t\t// Set decimals based off the `asset`.\n\t\tS.decimals = ERC20(_asset).decimals();\n\t\t// Set initial chain id for permit replay protection.\n\t\trequire(block.chainid < type(uint88).max, \"invalid chain id\");\n\t\tS.INITIAL_CHAIN_ID = uint88(block.chainid);\n\t\t// Set the initial domain separator for permit functions.\n\t\tS.INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator(S);\n\n\t\t// Default to a 10 day profit unlock period.\n\t\tS.profitMaxUnlockTime = 10 days;\n\t\t// Set address to receive performance fees.\n\t\t// Can't be address(0) or we will be burning fees.\n\t\trequire(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n\t\t// Can't mint shares to its self because of profit locking.\n\t\trequire(_performanceFeeRecipient != address(this), \"self\");\n\t\tS.performanceFeeRecipient = _performanceFeeRecipient;\n\t\t// Default to a 10% performance fee.\n\t\tS.performanceFee = 1_000;\n\t\t// Set last report to this block.\n\t\tS.lastReport = uint96(block.timestamp);\n\n\t\t// Set the default management address. Can't be 0.\n\t\trequire(_management != address(0), \"ZERO ADDRESS\");\n\t\tS.management = _management;\n\t\t// Set the keeper address\n\t\tS.keeper = _keeper;\n\n\t\t// Emit event to signal a new strategy has been initialized.\n\t\temit NewTokenizedStrategy(address(this), _asset, API_VERSION);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                      ERC4626 WRITE METHODS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Mints `shares` of strategy shares to `receiver` by\n\t * depositing exactly `assets` of underlying tokens.\n\t * @param assets The amount of underlying to deposit in.\n\t * @param receiver The address to receive the `shares`.\n\t * @return shares The actual amount of shares issued.\n\t */\n\tfunction deposit(\n\t\tuint256 assets,\n\t\taddress receiver\n\t) external nonReentrant returns (uint256 shares) {\n\t\t// Get the storage slot for all following calls.\n\t\tStrategyData storage S = _strategyStorage();\n\t\t// Checking max deposit will also check if shutdown.\n\t\trequire(\n\t\t\tassets <= _maxDeposit(S, receiver),\n\t\t\t\"ERC4626: deposit more than max\"\n\t\t);\n\t\t// Check for rounding error.\n\t\trequire(\n\t\t\t(shares = _convertToShares(S, assets, Math.Rounding.Down)) != 0,\n\t\t\t\"ZERO_SHARES\"\n\t\t);\n\n\t\t_deposit(S, receiver, assets, shares);\n\t}\n\n\t/**\n\t * @notice Mints exactly `shares` of strategy shares to\n\t * `receiver` by depositing `assets` of underlying tokens.\n\t * @param shares The amount of strategy shares mint.\n\t * @param receiver The address to receive the `shares`.\n\t * @return assets The actual amount of asset deposited.\n\t */\n\tfunction mint(\n\t\tuint256 shares,\n\t\taddress receiver\n\t) external nonReentrant returns (uint256 assets) {\n\t\t// Get the storage slot for all following calls.\n\t\tStrategyData storage S = _strategyStorage();\n\t\t// Checking max mint will also check if shutdown.\n\t\trequire(shares <= _maxMint(S, receiver), \"ERC4626: mint more than max\");\n\t\t// Check for rounding error.\n\t\trequire(\n\t\t\t(assets = _convertToAssets(S, shares, Math.Rounding.Up)) != 0,\n\t\t\t\"ZERO_ASSETS\"\n\t\t);\n\n\t\t_deposit(S, receiver, assets, shares);\n\t}\n\n\t/**\n\t * @notice Withdraws exactly `assets` from `owners` shares and sends\n\t * the underlying tokens to `receiver`.\n\t * @dev This will default to not allowing any loss to be taken.\n\t * @param assets The amount of underlying to withdraw.\n\t * @param receiver The address to receive `assets`.\n\t * @param owner The address whose shares are burnt.\n\t * @return shares The actual amount of shares burnt.\n\t */\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256 shares) {\n\t\treturn withdraw(assets, receiver, owner, 0);\n\t}\n\n\t/**\n\t * @notice Withdraws `assets` from `owners` shares and sends\n\t * the underlying tokens to `receiver`.\n\t * @dev This includes an added parameter to allow for losses.\n\t * @param assets The amount of underlying to withdraw.\n\t * @param receiver The address to receive `assets`.\n\t * @param owner The address whose shares are burnt.\n\t * @param maxLoss The amount of acceptable loss in Basis points.\n\t * @return shares The actual amount of shares burnt.\n\t */\n\tfunction withdraw(\n\t\tuint256 assets,\n\t\taddress receiver,\n\t\taddress owner,\n\t\tuint256 maxLoss\n\t) public nonReentrant returns (uint256 shares) {\n\t\t// Get the storage slot for all following calls.\n\t\tStrategyData storage S = _strategyStorage();\n\t\trequire(\n\t\t\tassets <= _maxWithdraw(S, owner),\n\t\t\t\"ERC4626: withdraw more than max\"\n\t\t);\n\t\t// Check for rounding error or 0 value.\n\t\trequire(\n\t\t\t(shares = _convertToShares(S, assets, Math.Rounding.Up)) != 0,\n\t\t\t\"ZERO_SHARES\"\n\t\t);\n\n\t\t// Withdraw and track the actual amount withdrawn for loss check.\n\t\t_withdraw(S, receiver, owner, assets, shares, maxLoss);\n\t}\n\n\t/**\n\t * @notice Redeems exactly `shares` from `owner` and\n\t * sends `assets` of underlying tokens to `receiver`.\n\t * @dev This will default to allowing any loss passed to be realized.\n\t * @param shares The amount of shares burnt.\n\t * @param receiver The address to receive `assets`.\n\t * @param owner The address whose shares are burnt.\n\t * @return assets The actual amount of underlying withdrawn.\n\t */\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner\n\t) external returns (uint256) {\n\t\t// We default to not limiting a potential loss.\n\t\treturn redeem(shares, receiver, owner, MAX_BPS);\n\t}\n\n\t/**\n\t * @notice Redeems exactly `shares` from `owner` and\n\t * sends `assets` of underlying tokens to `receiver`.\n\t * @dev This includes an added parameter to allow for losses.\n\t * @param shares The amount of shares burnt.\n\t * @param receiver The address to receive `assets`.\n\t * @param owner The address whose shares are burnt.\n\t * @param maxLoss The amount of acceptable loss in Basis points.\n\t * @return . The actual amount of underlying withdrawn.\n\t */\n\tfunction redeem(\n\t\tuint256 shares,\n\t\taddress receiver,\n\t\taddress owner,\n\t\tuint256 maxLoss\n\t) public nonReentrant returns (uint256) {\n\t\t// Get the storage slot for all following calls.\n\t\tStrategyData storage S = _strategyStorage();\n\t\trequire(\n\t\t\tshares <= _maxRedeem(S, owner),\n\t\t\t\"ERC4626: redeem more than max\"\n\t\t);\n\t\tuint256 assets;\n\t\t// Check for rounding error or 0 value.\n\t\trequire(\n\t\t\t(assets = _convertToAssets(S, shares, Math.Rounding.Down)) != 0,\n\t\t\t\"ZERO_ASSETS\"\n\t\t);\n\n\t\t// We need to return the actual amount withdrawn in case of a loss.\n\t\treturn _withdraw(S, receiver, owner, assets, shares, maxLoss);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                    EXTERNAL 4626 VIEW METHODS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Get the total amount of assets this strategy holds\n\t * as of the last report.\n\t *\n\t * We manually track `totalAssets` to avoid any PPS manipulation.\n\t *\n\t * @return . Total assets the strategy holds.\n\t */\n\tfunction totalAssets() external view returns (uint256) {\n\t\treturn _totalAssets(_strategyStorage());\n\t}\n\n\t/**\n\t * @notice Get the current supply of the strategies shares.\n\t *\n\t * Locked shares issued to the strategy from profits are not\n\t * counted towards the full supply until they are unlocked.\n\t *\n\t * As more shares slowly unlock the totalSupply will decrease\n\t * causing the PPS of the strategy to increase.\n\t *\n\t * @return . Total amount of shares outstanding.\n\t */\n\tfunction totalSupply() external view returns (uint256) {\n\t\treturn _totalSupply(_strategyStorage());\n\t}\n\n\t/**\n\t * @notice The amount of shares that the strategy would\n\t *  exchange for the amount of assets provided, in an\n\t * ideal scenario where all the conditions are met.\n\t *\n\t * @param assets The amount of underlying.\n\t * @return . Expected shares that `assets` represents.\n\t */\n\tfunction convertToShares(uint256 assets) external view returns (uint256) {\n\t\treturn _convertToShares(_strategyStorage(), assets, Math.Rounding.Down);\n\t}\n\n\t/**\n\t * @notice The amount of assets that the strategy would\n\t * exchange for the amount of shares provided, in an\n\t * ideal scenario where all the conditions are met.\n\t *\n\t * @param shares The amount of the strategies shares.\n\t * @return . Expected amount of `asset` the shares represents.\n\t */\n\tfunction convertToAssets(uint256 shares) external view returns (uint256) {\n\t\treturn _convertToAssets(_strategyStorage(), shares, Math.Rounding.Down);\n\t}\n\n\t/**\n\t * @notice Allows an on-chain or off-chain user to simulate\n\t * the effects of their deposit at the current block, given\n\t * current on-chain conditions.\n\t * @dev This will round down.\n\t *\n\t * @param assets The amount of `asset` to deposits.\n\t * @return . Expected shares that would be issued.\n\t */\n\tfunction previewDeposit(uint256 assets) external view returns (uint256) {\n\t\treturn _convertToShares(_strategyStorage(), assets, Math.Rounding.Down);\n\t}\n\n\t/**\n\t * @notice Allows an on-chain or off-chain user to simulate\n\t * the effects of their mint at the current block, given\n\t * current on-chain conditions.\n\t * @dev This is used instead of convertToAssets so that it can\n\t * round up for safer mints.\n\t *\n\t * @param shares The amount of shares to mint.\n\t * @return . The needed amount of `asset` for the mint.\n\t */\n\tfunction previewMint(uint256 shares) external view returns (uint256) {\n\t\treturn _convertToAssets(_strategyStorage(), shares, Math.Rounding.Up);\n\t}\n\n\t/**\n\t * @notice Allows an on-chain or off-chain user to simulate\n\t * the effects of their withdrawal at the current block,\n\t * given current on-chain conditions.\n\t * @dev This is used instead of convertToShares so that it can\n\t * round up for safer withdraws.\n\t *\n\t * @param assets The amount of `asset` that would be withdrawn.\n\t * @return . The amount of shares that would be burnt.\n\t */\n\tfunction previewWithdraw(uint256 assets) external view returns (uint256) {\n\t\treturn _convertToShares(_strategyStorage(), assets, Math.Rounding.Up);\n\t}\n\n\t/**\n\t * @notice Allows an on-chain or off-chain user to simulate\n\t * the effects of their redemption at the current block,\n\t * given current on-chain conditions.\n\t * @dev This will round down.\n\t *\n\t * @param shares The amount of shares that would be redeemed.\n\t * @return . The amount of `asset` that would be returned.\n\t */\n\tfunction previewRedeem(uint256 shares) external view returns (uint256) {\n\t\treturn _convertToAssets(_strategyStorage(), shares, Math.Rounding.Down);\n\t}\n\n\t/**\n\t * @notice Total number of underlying assets that can\n\t * be deposited by `_owner` into the strategy, where `owner`\n\t * corresponds to the receiver of a {deposit} call.\n\t *\n\t * @param owner The address depositing.\n\t * @return . The max that `owner` can deposit in `asset`.\n\t */\n\tfunction maxDeposit(address owner) external view returns (uint256) {\n\t\treturn _maxDeposit(_strategyStorage(), owner);\n\t}\n\n\t/**\n\t * @notice Total number of shares that can be minted by `owner`\n\t * into the strategy, where `_owner` corresponds to the receiver\n\t * of a {mint} call.\n\t *\n\t * @param owner The address minting.\n\t * @return _maxMint The max that `owner` can mint in shares.\n\t */\n\tfunction maxMint(address owner) external view returns (uint256) {\n\t\treturn _maxMint(_strategyStorage(), owner);\n\t}\n\n\t/**\n\t * @notice Total number of underlying assets that can be\n\t * withdrawn from the strategy by `owner`, where `owner`\n\t * corresponds to the msg.sender of a {redeem} call.\n\t *\n\t * @param owner The owner of the shares.\n\t * @return _maxWithdraw Max amount of `asset` that can be withdrawn.\n\t */\n\tfunction maxWithdraw(address owner) external view returns (uint256) {\n\t\treturn _maxWithdraw(_strategyStorage(), owner);\n\t}\n\n\t/**\n\t * @notice Total number of strategy shares that can be\n\t * redeemed from the strategy by `owner`, where `owner`\n\t * corresponds to the msg.sender of a {redeem} call.\n\t *\n\t * @param owner The owner of the shares.\n\t * @return _maxRedeem Max amount of shares that can be redeemed.\n\t */\n\tfunction maxRedeem(address owner) external view returns (uint256) {\n\t\treturn _maxRedeem(_strategyStorage(), owner);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                    INTERNAL 4626 VIEW METHODS\n    //////////////////////////////////////////////////////////////*/\n\n\t/// @dev Internal implementation of {totalAssets}.\n\tfunction _totalAssets(\n\t\tStrategyData storage S\n\t) internal view returns (uint256) {\n\t\treturn S.totalAssets;\n\t}\n\n\t/// @dev Internal implementation of {totalSupply}.\n\tfunction _totalSupply(\n\t\tStrategyData storage S\n\t) internal view returns (uint256) {\n\t\treturn S.totalSupply - _unlockedShares(S);\n\t}\n\n\t/// @dev Internal implementation of {convertToShares}.\n\tfunction _convertToShares(\n\t\tStrategyData storage S,\n\t\tuint256 assets,\n\t\tMath.Rounding _rounding\n\t) internal view returns (uint256) {\n\t\t// Saves an extra SLOAD if totalAssets() is non-zero.\n\t\tuint256 totalAssets_ = _totalAssets(S);\n\t\tuint256 totalSupply_ = _totalSupply(S);\n\n\t\t// If assets are 0 but supply is not PPS = 0.\n\t\tif (totalAssets_ == 0) return totalSupply_ == 0 ? assets : 0;\n\n\t\treturn assets.mulDiv(totalSupply_, totalAssets_, _rounding);\n\t}\n\n\t/// @dev Internal implementation of {convertToAssets}.\n\tfunction _convertToAssets(\n\t\tStrategyData storage S,\n\t\tuint256 shares,\n\t\tMath.Rounding _rounding\n\t) internal view returns (uint256) {\n\t\t// Saves an extra SLOAD if totalSupply() is non-zero.\n\t\tuint256 supply = _totalSupply(S);\n\n\t\treturn\n\t\t\tsupply == 0\n\t\t\t\t? shares\n\t\t\t\t: shares.mulDiv(_totalAssets(S), supply, _rounding);\n\t}\n\n\t/// @dev Internal implementation of {maxDeposit}.\n\tfunction _maxDeposit(\n\t\tStrategyData storage S,\n\t\taddress owner\n\t) internal view returns (uint256) {\n\t\t// Cannot deposit when shutdown.\n\t\tif (S.shutdown) return 0;\n\n\t\treturn IBaseStrategy(address(this)).availableDepositLimit(owner);\n\t}\n\n\t/// @dev Internal implementation of {maxMint}.\n\tfunction _maxMint(\n\t\tStrategyData storage S,\n\t\taddress owner\n\t) internal view returns (uint256 maxMint_) {\n\t\t// Cannot mint when shutdown.\n\t\tif (S.shutdown) return 0;\n\n\t\tmaxMint_ = IBaseStrategy(address(this)).availableDepositLimit(owner);\n\t\tif (maxMint_ != type(uint256).max) {\n\t\t\tmaxMint_ = _convertToShares(S, maxMint_, Math.Rounding.Down);\n\t\t}\n\t}\n\n\t/// @dev Internal implementation of {maxWithdraw}.\n\tfunction _maxWithdraw(\n\t\tStrategyData storage S,\n\t\taddress owner\n\t) internal view returns (uint256 maxWithdraw_) {\n\t\t// Get the max the owner could withdraw currently.\n\t\tmaxWithdraw_ = IBaseStrategy(address(this)).availableWithdrawLimit(\n\t\t\towner\n\t\t);\n\n\t\t// If there is no limit enforced.\n\t\tif (maxWithdraw_ == type(uint256).max) {\n\t\t\t// Saves a min check if there is no withdrawal limit.\n\t\t\tmaxWithdraw_ = _convertToAssets(\n\t\t\t\tS,\n\t\t\t\t_balanceOf(S, owner),\n\t\t\t\tMath.Rounding.Down\n\t\t\t);\n\t\t} else {\n\t\t\tmaxWithdraw_ = Math.min(\n\t\t\t\t_convertToAssets(S, _balanceOf(S, owner), Math.Rounding.Down),\n\t\t\t\tmaxWithdraw_\n\t\t\t);\n\t\t}\n\t}\n\n\t/// @dev Internal implementation of {maxRedeem}.\n\tfunction _maxRedeem(\n\t\tStrategyData storage S,\n\t\taddress owner\n\t) internal view returns (uint256 maxRedeem_) {\n\t\t// Get the max the owner could withdraw currently.\n\t\tmaxRedeem_ = IBaseStrategy(address(this)).availableWithdrawLimit(owner);\n\n\t\t// Conversion would overflow and saves a min check if there is no withdrawal limit.\n\t\tif (maxRedeem_ == type(uint256).max) {\n\t\t\tmaxRedeem_ = _balanceOf(S, owner);\n\t\t} else {\n\t\t\tmaxRedeem_ = Math.min(\n\t\t\t\t// Can't redeem more than the balance.\n\t\t\t\t_convertToShares(S, maxRedeem_, Math.Rounding.Down),\n\t\t\t\t_balanceOf(S, owner)\n\t\t\t);\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                    INTERNAL 4626 WRITE METHODS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev Function to be called during {deposit} and {mint}.\n\t *\n\t * This function handles all logic including transfers,\n\t * minting and accounting.\n\t *\n\t * We do all external calls before updating any internal\n\t * values to prevent view reentrancy issues from the token\n\t * transfers or the _deployFunds() calls.\n\t */\n\tfunction _deposit(\n\t\tStrategyData storage S,\n\t\taddress receiver,\n\t\tuint256 assets,\n\t\tuint256 shares\n\t) internal {\n\t\trequire(receiver != address(this), \"ERC4626: mint to self\");\n\n\t\t// Cache storage variables used more than once.\n\t\tERC20 _asset = S.asset;\n\n\t\t// Need to transfer before minting or ERC777s could reenter.\n\t\t_asset.safeTransferFrom(msg.sender, address(this), assets);\n\n\t\t// We can deploy the full loose balance currently held.\n\t\tIBaseStrategy(address(this)).deployFunds(\n\t\t\t_asset.balanceOf(address(this))\n\t\t);\n\n\t\t// Adjust total Assets.\n\t\tS.totalAssets += assets;\n\n\t\t// mint shares\n\t\t_mint(S, receiver, shares);\n\n\t\temit Deposit(msg.sender, receiver, assets, shares);\n\t}\n\n\t/**\n\t * @dev To be called during {redeem} and {withdraw}.\n\t *\n\t * This will handle all logic, transfers and accounting\n\t * in order to service the withdraw request.\n\t *\n\t * If we are not able to withdraw the full amount needed, it will\n\t * be counted as a loss and passed on to the user.\n\t */\n\tfunction _withdraw(\n\t\tStrategyData storage S,\n\t\taddress receiver,\n\t\taddress owner,\n\t\tuint256 assets,\n\t\tuint256 shares,\n\t\tuint256 maxLoss\n\t) internal returns (uint256) {\n\t\trequire(receiver != address(0), \"ZERO ADDRESS\");\n\t\trequire(maxLoss <= MAX_BPS, \"exceeds MAX_BPS\");\n\n\t\t// Spend allowance if applicable.\n\t\tif (msg.sender != owner) {\n\t\t\t_spendAllowance(S, owner, msg.sender, shares);\n\t\t}\n\n\t\t// Cache `asset` since it is used multiple times..\n\t\tERC20 _asset = S.asset;\n\n\t\tuint256 idle = _asset.balanceOf(address(this));\n\t\tuint256 loss;\n\t\t// Check if we need to withdraw funds.\n\t\tif (idle < assets) {\n\t\t\t// Tell Strategy to free what we need.\n\t\t\tunchecked {\n\t\t\t\tIBaseStrategy(address(this)).freeFunds(assets - idle);\n\t\t\t}\n\n\t\t\t// Return the actual amount withdrawn. Adjust for potential under withdraws.\n\t\t\tidle = _asset.balanceOf(address(this));\n\n\t\t\t// If we didn't get enough out then we have a loss.\n\t\t\tif (idle < assets) {\n\t\t\t\tunchecked {\n\t\t\t\t\tloss = assets - idle;\n\t\t\t\t}\n\t\t\t\t// If a non-default max loss parameter was set.\n\t\t\t\tif (maxLoss < MAX_BPS) {\n\t\t\t\t\t// Make sure we are within the acceptable range.\n\t\t\t\t\trequire(\n\t\t\t\t\t\tloss <= (assets * maxLoss) / MAX_BPS,\n\t\t\t\t\t\t\"too much loss\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Lower the amount to be withdrawn.\n\t\t\t\tassets = idle;\n\t\t\t}\n\t\t}\n\n\t\t// Update assets based on how much we took.\n\t\tS.totalAssets -= (assets + loss);\n\n\t\t_burn(S, owner, shares);\n\n\t\t// Transfer the amount of underlying to the receiver.\n\t\t_asset.safeTransfer(receiver, assets);\n\n\t\temit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n\t\t// Return the actual amount of assets withdrawn.\n\t\treturn assets;\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        PROFIT REPORTING\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Function for keepers to call to harvest and record all\n\t * profits accrued.\n\t *\n\t * @dev This will account for any gains/losses since the last report\n\t * and charge fees accordingly.\n\t *\n\t * Any profit over the fees charged will be immediately locked\n\t * so there is no change in PricePerShare. Then slowly unlocked\n\t * over the `maxProfitUnlockTime` each second based on the\n\t * calculated `profitUnlockingRate`.\n\t *\n\t * In case of a loss it will first attempt to offset the loss\n\t * with any remaining locked shares from the last report in\n\t * order to reduce any negative impact to PPS.\n\t *\n\t * Will then recalculate the new time to unlock profits over and the\n\t * rate based on a weighted average of any remaining time from the\n\t * last report and the new amount of shares to be locked.\n\t *\n\t * @return profit The notional amount of gain if any since the last\n\t * report in terms of `asset`.\n\t * @return loss The notional amount of loss if any since the last\n\t * report in terms of `asset`.\n\t */\n\tfunction report()\n\t\texternal\n\t\tnonReentrant\n\t\tonlyKeepers\n\t\treturns (uint256 profit, uint256 loss)\n\t{\n\t\t// Cache storage pointer since its used repeatedly.\n\t\tStrategyData storage S = _strategyStorage();\n\n\t\t// Tell the strategy to report the real total assets it has.\n\t\t// It should do all reward selling and redepositing now and\n\t\t// account for deployed and loose `asset` so we can accurately\n\t\t// account for all funds including those potentially airdropped\n\t\t// and then have any profits immediately locked.\n\t\tuint256 newTotalAssets = IBaseStrategy(address(this))\n\t\t\t.harvestAndReport();\n\n\t\tuint256 oldTotalAssets = _totalAssets(S);\n\n\t\t// Get the amount of shares we need to burn from previous reports.\n\t\tuint256 sharesToBurn = _unlockedShares(S);\n\n\t\t// Initialize variables needed throughout.\n\t\tuint256 totalFees;\n\t\tuint256 protocolFees;\n\t\tuint256 sharesToLock;\n\t\tuint256 _profitMaxUnlockTime = S.profitMaxUnlockTime;\n\t\t// Calculate profit/loss.\n\t\tif (newTotalAssets > oldTotalAssets) {\n\t\t\t// We have a profit.\n\t\t\tunchecked {\n\t\t\t\tprofit = newTotalAssets - oldTotalAssets;\n\t\t\t}\n\n\t\t\t// We need to get the equivalent amount of shares\n\t\t\t// at the current PPS before any minting or burning.\n\t\t\tsharesToLock = _convertToShares(S, profit, Math.Rounding.Down);\n\n\t\t\t// Cache the performance fee.\n\t\t\tuint16 fee = S.performanceFee;\n\t\t\tuint256 totalFeeShares;\n\t\t\t// If we are charging a performance fee\n\t\t\tif (fee != 0) {\n\t\t\t\t// Asses performance fees.\n\t\t\t\tunchecked {\n\t\t\t\t\t// Get in `asset` for the event.\n\t\t\t\t\ttotalFees = (profit * fee) / MAX_BPS;\n\t\t\t\t\t// And in shares for the payment.\n\t\t\t\t\ttotalFeeShares = (sharesToLock * fee) / MAX_BPS;\n\t\t\t\t}\n\n\t\t\t\t// Get the protocol fee config from the factory.\n\t\t\t\t(\n\t\t\t\t\tuint16 protocolFeeBps,\n\t\t\t\t\taddress protocolFeesRecipient\n\t\t\t\t) = IFactory(FACTORY).protocol_fee_config();\n\n\t\t\t\tuint256 protocolFeeShares;\n\t\t\t\t// Check if there is a protocol fee to charge.\n\t\t\t\tif (protocolFeeBps != 0) {\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\t// Calculate protocol fees based on the performance Fees.\n\t\t\t\t\t\tprotocolFeeShares =\n\t\t\t\t\t\t\t(totalFeeShares * protocolFeeBps) /\n\t\t\t\t\t\t\tMAX_BPS;\n\t\t\t\t\t\t// Need amount in underlying for event.\n\t\t\t\t\t\tprotocolFees = (totalFees * protocolFeeBps) / MAX_BPS;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Mint the protocol fees to the recipient.\n\t\t\t\t\t_mint(S, protocolFeesRecipient, protocolFeeShares);\n\t\t\t\t}\n\n\t\t\t\t// Mint the difference to the strategy fee recipient.\n\t\t\t\tunchecked {\n\t\t\t\t\t_mint(\n\t\t\t\t\t\tS,\n\t\t\t\t\t\tS.performanceFeeRecipient,\n\t\t\t\t\t\ttotalFeeShares - protocolFeeShares\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if we are locking profit.\n\t\t\tif (_profitMaxUnlockTime != 0) {\n\t\t\t\t// lock (profit - fees)\n\t\t\t\tunchecked {\n\t\t\t\t\tsharesToLock -= totalFeeShares;\n\t\t\t\t}\n\n\t\t\t\t// If we are burning more than re-locking.\n\t\t\t\tif (sharesToBurn > sharesToLock) {\n\t\t\t\t\t// Burn the difference\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\t_burn(S, address(this), sharesToBurn - sharesToLock);\n\t\t\t\t\t}\n\t\t\t\t} else if (sharesToLock > sharesToBurn) {\n\t\t\t\t\t// Mint the shares to lock the strategy.\n\t\t\t\t\tunchecked {\n\t\t\t\t\t\t_mint(S, address(this), sharesToLock - sharesToBurn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Expect we have a loss.\n\t\t\tunchecked {\n\t\t\t\tloss = oldTotalAssets - newTotalAssets;\n\t\t\t}\n\n\t\t\t// Check in case `else` was due to being equal.\n\t\t\tif (loss != 0) {\n\t\t\t\t// We will try and burn the unlocked shares and as much from any\n\t\t\t\t// pending profit still unlocking to offset the loss to prevent any PPS decline post report.\n\t\t\t\tsharesToBurn = Math.min(\n\t\t\t\t\t// Cannot burn more than we have.\n\t\t\t\t\tS.balances[address(this)],\n\t\t\t\t\t// Try and burn both the shares already unlocked and the amount for the loss.\n\t\t\t\t\t_convertToShares(S, loss, Math.Rounding.Down) + sharesToBurn\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Check if there is anything to burn.\n\t\t\tif (sharesToBurn != 0) {\n\t\t\t\t_burn(S, address(this), sharesToBurn);\n\t\t\t}\n\t\t}\n\n\t\t// Update unlocking rate and time to fully unlocked.\n\t\tuint256 totalLockedShares = S.balances[address(this)];\n\t\tif (totalLockedShares != 0) {\n\t\t\tuint256 previouslyLockedTime;\n\t\t\tuint96 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n\t\t\t// Check if we need to account for shares still unlocking.\n\t\t\tif (_fullProfitUnlockDate > block.timestamp) {\n\t\t\t\tunchecked {\n\t\t\t\t\t// There will only be previously locked shares if time remains.\n\t\t\t\t\t// We calculate this here since it should be rare.\n\t\t\t\t\tpreviouslyLockedTime =\n\t\t\t\t\t\t(_fullProfitUnlockDate - block.timestamp) *\n\t\t\t\t\t\t(totalLockedShares - sharesToLock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// newProfitLockingPeriod is a weighted average between the remaining\n\t\t\t// time of the previously locked shares and the profitMaxUnlockTime.\n\t\t\tuint256 newProfitLockingPeriod = (previouslyLockedTime +\n\t\t\t\tsharesToLock *\n\t\t\t\t_profitMaxUnlockTime) / totalLockedShares;\n\n\t\t\t// Calculate how many shares unlock per second.\n\t\t\tS.profitUnlockingRate =\n\t\t\t\t(totalLockedShares * MAX_BPS_EXTENDED) /\n\t\t\t\tnewProfitLockingPeriod;\n\n\t\t\t// Calculate how long until the full amount of shares is unlocked.\n\t\t\tS.fullProfitUnlockDate = uint96(\n\t\t\t\tblock.timestamp + newProfitLockingPeriod\n\t\t\t);\n\t\t} else {\n\t\t\t// Only setting this to 0 will turn in the desired effect,\n\t\t\t// no need to update profitUnlockingRate.\n\t\t\tS.fullProfitUnlockDate = 0;\n\t\t}\n\n\t\t// Update the new total assets value.\n\t\tS.totalAssets = newTotalAssets;\n\t\tS.lastReport = uint96(block.timestamp);\n\n\t\t// Emit event with info\n\t\temit Reported(\n\t\t\tprofit,\n\t\t\tloss,\n\t\t\tprotocolFees, // Protocol fees\n\t\t\ttotalFees - protocolFees // Performance Fees\n\t\t);\n\t}\n\n\t/**\n\t * @notice Get how many shares have been unlocked since last report.\n\t * @return . The amount of shares that have unlocked.\n\t */\n\tfunction unlockedShares() external view returns (uint256) {\n\t\treturn _unlockedShares(_strategyStorage());\n\t}\n\n\t/**\n\t * @dev To determine how many of the shares that were locked during the last\n\t * report have since unlocked.\n\t *\n\t * If the `fullProfitUnlockDate` has passed the full strategy's balance will\n\t * count as unlocked.\n\t *\n\t * @return unlocked The amount of shares that have unlocked.\n\t */\n\tfunction _unlockedShares(\n\t\tStrategyData storage S\n\t) internal view returns (uint256 unlocked) {\n\t\tuint96 _fullProfitUnlockDate = S.fullProfitUnlockDate;\n\t\tif (_fullProfitUnlockDate > block.timestamp) {\n\t\t\tunchecked {\n\t\t\t\tunlocked =\n\t\t\t\t\t(S.profitUnlockingRate * (block.timestamp - S.lastReport)) /\n\t\t\t\t\tMAX_BPS_EXTENDED;\n\t\t\t}\n\t\t} else if (_fullProfitUnlockDate != 0) {\n\t\t\t// All shares have been unlocked.\n\t\t\tunlocked = S.balances[address(this)];\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                            TENDING\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice For a 'keeper' to 'tend' the strategy if a custom\n\t * tendTrigger() is implemented.\n\t *\n\t * @dev Both 'tendTrigger' and '_tend' will need to be overridden\n\t * for this to be used.\n\t *\n\t * This will callback the internal '_tend' call in the BaseStrategy\n\t * with the total current amount available to the strategy to deploy.\n\t *\n\t * This is a permissioned function so if desired it could\n\t * be used for illiquid or manipulatable strategies to compound\n\t * rewards, perform maintenance or deposit/withdraw funds.\n\t *\n\t * This will not cause any change in PPS. Total assets will\n\t * be the same before and after.\n\t *\n\t * A report() call will be needed to record any profits or losses.\n\t */\n\tfunction tend() external nonReentrant onlyKeepers {\n\t\t// Tend the strategy with the current loose balance.\n\t\tIBaseStrategy(address(this)).tendThis(\n\t\t\t_strategyStorage().asset.balanceOf(address(this))\n\t\t);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        STRATEGY SHUTDOWN\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Used to shutdown the strategy preventing any further deposits.\n\t * @dev Can only be called by the current `management` or `emergencyAdmin`.\n\t *\n\t * This will stop any new {deposit} or {mint} calls but will\n\t * not prevent {withdraw} or {redeem}. It will also still allow for\n\t * {tend} and {report} so that management can report any last losses\n\t * in an emergency as well as provide any maintenance to allow for full\n\t * withdraw.\n\t *\n\t * This is a one way switch and can never be set back once shutdown.\n\t */\n\tfunction shutdownStrategy() external onlyEmergencyAuthorized {\n\t\t_strategyStorage().shutdown = true;\n\n\t\temit StrategyShutdown();\n\t}\n\n\t/**\n\t * @notice To manually withdraw funds from the yield source after a\n\t * strategy has been shutdown.\n\t * @dev This can only be called post {shutdownStrategy}.\n\t *\n\t * This will never cause a change in PPS. Total assets will\n\t * be the same before and after.\n\t *\n\t * A strategist will need to override the {_emergencyWithdraw} function\n\t * in their strategy for this to work.\n\t *\n\t * @param amount The amount of asset to attempt to free.\n\t */\n\tfunction emergencyWithdraw(\n\t\tuint256 amount\n\t) external nonReentrant onlyEmergencyAuthorized {\n\t\t// Make sure the strategy has been shutdown.\n\t\trequire(_strategyStorage().shutdown, \"not shutdown\");\n\n\t\t// Withdraw from the yield source.\n\t\tIBaseStrategy(address(this)).shutdownWithdraw(amount);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        GETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Get the underlying asset for the strategy.\n\t * @return . The underlying asset.\n\t */\n\tfunction asset() external view returns (address) {\n\t\treturn address(_strategyStorage().asset);\n\t}\n\n\t/**\n\t * @notice Get the API version for this TokenizedStrategy.\n\t * @return . The API version for this TokenizedStrategy\n\t */\n\tfunction apiVersion() external pure returns (string memory) {\n\t\treturn API_VERSION;\n\t}\n\n\t/**\n\t * @notice Get the current address that controls the strategy.\n\t * @return . Address of management\n\t */\n\tfunction management() external view returns (address) {\n\t\treturn _strategyStorage().management;\n\t}\n\n\t/**\n\t * @notice Get the current pending management address if any.\n\t * @return . Address of pendingManagement\n\t */\n\tfunction pendingManagement() external view returns (address) {\n\t\treturn _strategyStorage().pendingManagement;\n\t}\n\n\t/**\n\t * @notice Get the current address that can call tend and report.\n\t * @return . Address of the keeper\n\t */\n\tfunction keeper() external view returns (address) {\n\t\treturn _strategyStorage().keeper;\n\t}\n\n\t/**\n\t * @notice Get the current address that can shutdown and emergency withdraw.\n\t * @return . Address of the emergencyAdmin\n\t */\n\tfunction emergencyAdmin() external view returns (address) {\n\t\treturn _strategyStorage().emergencyAdmin;\n\t}\n\n\t/**\n\t * @notice Get the current performance fee charged on profits.\n\t * denominated in Basis Points where 10_000 == 100%\n\t * @return . Current performance fee.\n\t */\n\tfunction performanceFee() external view returns (uint16) {\n\t\treturn _strategyStorage().performanceFee;\n\t}\n\n\t/**\n\t * @notice Get the current address that receives the performance fees.\n\t * @return . Address of performanceFeeRecipient\n\t */\n\tfunction performanceFeeRecipient() external view returns (address) {\n\t\treturn _strategyStorage().performanceFeeRecipient;\n\t}\n\n\t/**\n\t * @notice Gets the timestamp at which all profits will be unlocked.\n\t * @return . The full profit unlocking timestamp\n\t */\n\tfunction fullProfitUnlockDate() external view returns (uint256) {\n\t\treturn uint256(_strategyStorage().fullProfitUnlockDate);\n\t}\n\n\t/**\n\t * @notice The per second rate at which profits are unlocking.\n\t * @dev This is denominated in EXTENDED_BPS decimals.\n\t * @return . The current profit unlocking rate.\n\t */\n\tfunction profitUnlockingRate() external view returns (uint256) {\n\t\treturn _strategyStorage().profitUnlockingRate;\n\t}\n\n\t/**\n\t * @notice Gets the current time profits are set to unlock over.\n\t * @return . The current profit max unlock time.\n\t */\n\tfunction profitMaxUnlockTime() external view returns (uint256) {\n\t\treturn _strategyStorage().profitMaxUnlockTime;\n\t}\n\n\t/**\n\t * @notice The timestamp of the last time protocol fees were charged.\n\t * @return . The last report.\n\t */\n\tfunction lastReport() external view returns (uint256) {\n\t\treturn uint256(_strategyStorage().lastReport);\n\t}\n\n\t/**\n\t * @notice Get the price per share.\n\t * @dev This value offers limited precision. Integrations that require\n\t * exact precision should use convertToAssets or convertToShares instead.\n\t *\n\t * @return . The price per share.\n\t */\n\tfunction pricePerShare() external view returns (uint256) {\n\t\tStrategyData storage S = _strategyStorage();\n\t\treturn _convertToAssets(S, 10 ** S.decimals, Math.Rounding.Down);\n\t}\n\n\t/**\n\t * @notice To check if the strategy has been shutdown.\n\t * @return . Whether or not the strategy is shutdown.\n\t */\n\tfunction isShutdown() external view returns (bool) {\n\t\treturn _strategyStorage().shutdown;\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        SETTER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Step one of two to set a new address to be in charge of the strategy.\n\t * @dev Can only be called by the current `management`. The address is\n\t * set to pending management and will then have to call {acceptManagement}\n\t * in order for the 'management' to officially change.\n\t *\n\t * Cannot set `management` to address(0).\n\t *\n\t * @param _management New address to set `pendingManagement` to.\n\t */\n\tfunction setPendingManagement(address _management) external onlyManagement {\n\t\trequire(_management != address(0), \"ZERO ADDRESS\");\n\t\t_strategyStorage().pendingManagement = _management;\n\n\t\temit UpdatePendingManagement(_management);\n\t}\n\n\t/**\n\t * @notice Step two of two to set a new 'management' of the strategy.\n\t * @dev Can only be called by the current `pendingManagement`.\n\t */\n\tfunction acceptManagement() external {\n\t\tStrategyData storage S = _strategyStorage();\n\t\trequire(msg.sender == S.pendingManagement, \"!pending\");\n\t\tS.management = msg.sender;\n\t\tS.pendingManagement = address(0);\n\n\t\temit UpdateManagement(msg.sender);\n\t}\n\n\t/**\n\t * @notice Sets a new address to be in charge of tend and reports.\n\t * @dev Can only be called by the current `management`.\n\t *\n\t * @param _keeper New address to set `keeper` to.\n\t */\n\tfunction setKeeper(address _keeper) external onlyManagement {\n\t\t_strategyStorage().keeper = _keeper;\n\n\t\temit UpdateKeeper(_keeper);\n\t}\n\n\t/**\n\t * @notice Sets a new address to be able to shutdown the strategy.\n\t * @dev Can only be called by the current `management`.\n\t *\n\t * @param _emergencyAdmin New address to set `emergencyAdmin` to.\n\t */\n\tfunction setEmergencyAdmin(\n\t\taddress _emergencyAdmin\n\t) external onlyManagement {\n\t\t_strategyStorage().emergencyAdmin = _emergencyAdmin;\n\n\t\temit UpdateEmergencyAdmin(_emergencyAdmin);\n\t}\n\n\t/**\n\t * @notice Sets the performance fee to be charged on reported gains.\n\t * @dev Can only be called by the current `management`.\n\t *\n\t * Denominated in Basis Points. So 100% == 10_000.\n\t * Cannot set greater than to MAX_FEE.\n\t *\n\t * @param _performanceFee New performance fee.\n\t */\n\tfunction setPerformanceFee(uint16 _performanceFee) external onlyManagement {\n\t\trequire(_performanceFee <= MAX_FEE, \"MAX FEE\");\n\t\t_strategyStorage().performanceFee = _performanceFee;\n\n\t\temit UpdatePerformanceFee(_performanceFee);\n\t}\n\n\t/**\n\t * @notice Sets a new address to receive performance fees.\n\t * @dev Can only be called by the current `management`.\n\t *\n\t * Cannot set to address(0).\n\t *\n\t * @param _performanceFeeRecipient New address to set `management` to.\n\t */\n\tfunction setPerformanceFeeRecipient(\n\t\taddress _performanceFeeRecipient\n\t) external onlyManagement {\n\t\trequire(_performanceFeeRecipient != address(0), \"ZERO ADDRESS\");\n\t\trequire(_performanceFeeRecipient != address(this), \"Cannot be self\");\n\t\t_strategyStorage().performanceFeeRecipient = _performanceFeeRecipient;\n\n\t\temit UpdatePerformanceFeeRecipient(_performanceFeeRecipient);\n\t}\n\n\t/**\n\t * @notice Sets the time for profits to be unlocked over.\n\t * @dev Can only be called by the current `management`.\n\t *\n\t * Denominated in seconds and cannot be greater than 1 year.\n\t *\n\t * NOTE: Setting to 0 will cause all currently locked profit\n\t * to be unlocked instantly and should be done with care.\n\t *\n\t * `profitMaxUnlockTime` is stored as a uint32 for packing but can\n\t * be passed in as uint256 for simplicity.\n\t *\n\t * @param _profitMaxUnlockTime New `profitMaxUnlockTime`.\n\t */\n\tfunction setProfitMaxUnlockTime(\n\t\tuint256 _profitMaxUnlockTime\n\t) external onlyManagement {\n\t\t// Must be less than a year.\n\t\trequire(_profitMaxUnlockTime <= SECONDS_PER_YEAR, \"too long\");\n\t\tStrategyData storage S = _strategyStorage();\n\n\t\t// If we are setting to 0 we need to adjust amounts.\n\t\tif (_profitMaxUnlockTime == 0) {\n\t\t\tuint256 shares = S.balances[address(this)];\n\t\t\tif (shares != 0) {\n\t\t\t\t// Burn all shares if applicable.\n\t\t\t\t_burn(S, address(this), shares);\n\t\t\t}\n\t\t\t// Reset unlocking variables\n\t\t\tS.profitUnlockingRate = 0;\n\t\t\tS.fullProfitUnlockDate = 0;\n\t\t}\n\n\t\tS.profitMaxUnlockTime = uint32(_profitMaxUnlockTime);\n\n\t\temit UpdateProfitMaxUnlockTime(_profitMaxUnlockTime);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                        ERC20 METHODS\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Returns the name of the token.\n\t * @return . The name the strategy is using for its token.\n\t */\n\tfunction name() external view returns (string memory) {\n\t\treturn _strategyStorage().name;\n\t}\n\n\t/**\n\t * @notice Returns the symbol of the strategies token.\n\t * @dev Will be 'ys + asset symbol'.\n\t * @return . The symbol the strategy is using for its tokens.\n\t */\n\tfunction symbol() external view returns (string memory) {\n\t\treturn\n\t\t\tstring(abi.encodePacked(\"ys\", _strategyStorage().asset.symbol()));\n\t}\n\n\t/**\n\t * @notice Returns the number of decimals used to get its user representation.\n\t * @return . The decimals used for the strategy and `asset`.\n\t */\n\tfunction decimals() external view returns (uint8) {\n\t\treturn _strategyStorage().decimals;\n\t}\n\n\t/**\n\t * @notice Returns the current balance for a given '_account'.\n\t * @dev If the '_account` is the strategy then this will subtract\n\t * the amount of shares that have been unlocked since the last profit first.\n\t * @param account the address to return the balance for.\n\t * @return . The current balance in y shares of the '_account'.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256) {\n\t\treturn _balanceOf(_strategyStorage(), account);\n\t}\n\n\t/// @dev Internal implementation of {balanceOf}.\n\tfunction _balanceOf(\n\t\tStrategyData storage S,\n\t\taddress account\n\t) internal view returns (uint256) {\n\t\tif (account == address(this)) {\n\t\t\treturn S.balances[account] - _unlockedShares(S);\n\t\t}\n\t\treturn S.balances[account];\n\t}\n\n\t/**\n\t * @notice Transfer '_amount` of shares from `msg.sender` to `to`.\n\t * @dev\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - `to` cannot be the address of the strategy.\n\t * - the caller must have a balance of at least `_amount`.\n\t *\n\t * @param to The address shares will be transferred to.\n\t * @param amount The amount of shares to be transferred from sender.\n\t * @return . a boolean value indicating whether the operation succeeded.\n\t */\n\tfunction transfer(address to, uint256 amount) external returns (bool) {\n\t\t_transfer(_strategyStorage(), msg.sender, to, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t * @param owner The address who owns the shares.\n\t * @param spender The address who would be moving the owners shares.\n\t * @return . The remaining amount of shares of `owner` that could be moved by `spender`.\n\t */\n\tfunction allowance(\n\t\taddress owner,\n\t\taddress spender\n\t) external view returns (uint256) {\n\t\treturn _allowance(_strategyStorage(), owner, spender);\n\t}\n\n\t/// @dev Internal implementation of {allowance}.\n\tfunction _allowance(\n\t\tStrategyData storage S,\n\t\taddress owner,\n\t\taddress spender\n\t) internal view returns (uint256) {\n\t\treturn S.allowances[owner][spender];\n\t}\n\n\t/**\n\t * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t * @dev\n\t *\n\t * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n\t * `transferFrom`. This is semantically equivalent to an infinite approval.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * @param spender the address to allow the shares to be moved by.\n\t * @param amount the amount of shares to allow `spender` to move.\n\t * @return . a boolean value indicating whether the operation succeeded.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool) {\n\t\t_approve(_strategyStorage(), msg.sender, spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice `amount` tokens from `from` to `to` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * @dev\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP.\n\t *\n\t * NOTE: Does not update the allowance if the current allowance\n\t * is the maximum `uint256`.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` and `to` cannot be the zero address.\n\t * - `to` cannot be the address of the strategy.\n\t * - `from` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``from``'s tokens of at least\n\t * `amount`.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * @param from the address to be moving shares from.\n\t * @param to the address to be moving shares to.\n\t * @param amount the quantity of shares to move.\n\t * @return . a boolean value indicating whether the operation succeeded.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) external returns (bool) {\n\t\tStrategyData storage S = _strategyStorage();\n\t\t_spendAllowance(S, from, msg.sender, amount);\n\t\t_transfer(S, from, to, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves `amount` of tokens from `from` to `to`.\n\t *\n\t * This internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `to` cannot be the strategies address\n\t * - `from` must have a balance of at least `amount`.\n\t *\n\t */\n\tfunction _transfer(\n\t\tStrategyData storage S,\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(from != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(to != address(0), \"ERC20: transfer to the zero address\");\n\t\trequire(to != address(this), \"ERC20 transfer to strategy\");\n\n\t\tS.balances[from] -= amount;\n\t\tunchecked {\n\t\t\tS.balances[to] += amount;\n\t\t}\n\n\t\temit Transfer(from, to, amount);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t *\n\t */\n\tfunction _mint(\n\t\tStrategyData storage S,\n\t\taddress account,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\tS.totalSupply += amount;\n\t\tunchecked {\n\t\t\tS.balances[account] += amount;\n\t\t}\n\t\temit Transfer(address(0), account, amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, reducing the\n\t * total supply.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `account` must have at least `amount` tokens.\n\t */\n\tfunction _burn(\n\t\tStrategyData storage S,\n\t\taddress account,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\tS.balances[account] -= amount;\n\t\tunchecked {\n\t\t\tS.totalSupply -= amount;\n\t\t}\n\t\temit Transfer(account, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction _approve(\n\t\tStrategyData storage S,\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\tS.allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n\t *\n\t * Does not update the allowance amount in case of infinite allowance.\n\t * Revert if not enough allowance is available.\n\t *\n\t * Might emit an {Approval} event.\n\t */\n\tfunction _spendAllowance(\n\t\tStrategyData storage S,\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal {\n\t\tuint256 currentAllowance = _allowance(S, owner, spender);\n\t\tif (currentAllowance != type(uint256).max) {\n\t\t\trequire(\n\t\t\t\tcurrentAllowance >= amount,\n\t\t\t\t\"ERC20: insufficient allowance\"\n\t\t\t);\n\t\t\tunchecked {\n\t\t\t\t_approve(S, owner, spender, currentAllowance - amount);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                            EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @notice Returns the current nonce for `owner`. This value must be\n\t * included whenever a signature is generated for {permit}.\n\t *\n\t * @dev Every successful call to {permit} increases ``owner``'s nonce by one. This\n\t * prevents a signature from being used multiple times.\n\t *\n\t * @param _owner the address of the account to return the nonce for.\n\t * @return . the current nonce for the account.\n\t */\n\tfunction nonces(address _owner) external view returns (uint256) {\n\t\treturn _strategyStorage().nonces[_owner];\n\t}\n\n\t/**\n\t * @notice Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n\t * given ``owner``'s signed approval.\n\t *\n\t * @dev IMPORTANT: The same issues {IERC20-approve} has related to transaction\n\t * ordering also apply here.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `deadline` must be a timestamp in the future.\n\t * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n\t * over the EIP712-formatted function arguments.\n\t * - the signature must use ``owner``'s current nonce (see {nonces}).\n\t *\n\t * For more information on the signature format, see the\n\t * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n\t * section].\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external {\n\t\trequire(deadline >= block.timestamp, \"ERC20: PERMIT_DEADLINE_EXPIRED\");\n\n\t\t// Unchecked because the only math done is incrementing\n\t\t// the owner's nonce which cannot realistically overflow.\n\t\tunchecked {\n\t\t\taddress recoveredAddress = ecrecover(\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\"\\x19\\x01\",\n\t\t\t\t\t\tDOMAIN_SEPARATOR(),\n\t\t\t\t\t\tkeccak256(\n\t\t\t\t\t\t\tabi.encode(\n\t\t\t\t\t\t\t\tkeccak256(\n\t\t\t\t\t\t\t\t\t\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\towner,\n\t\t\t\t\t\t\t\tspender,\n\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t_strategyStorage().nonces[owner]++,\n\t\t\t\t\t\t\t\tdeadline\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tv,\n\t\t\t\tr,\n\t\t\t\ts\n\t\t\t);\n\n\t\t\trequire(\n\t\t\t\trecoveredAddress != address(0) && recoveredAddress == owner,\n\t\t\t\t\"ERC20: INVALID_SIGNER\"\n\t\t\t);\n\n\t\t\t_approve(_strategyStorage(), recoveredAddress, spender, value);\n\t\t}\n\t}\n\n\t/**\n\t * @notice Returns the domain separator used in the encoding of the signature\n\t * for {permit}, as defined by {EIP712}.\n\t *\n\t * @dev This checks that the current chain id is the same as when the contract\n\t * was deployed to prevent replay attacks. If false it will calculate a new\n\t * domain separator based on the new chain id.\n\t *\n\t * @return . The domain separator that will be used for any {permit} calls.\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns (bytes32) {\n\t\tStrategyData storage S = _strategyStorage();\n\t\treturn\n\t\t\tblock.chainid == S.INITIAL_CHAIN_ID\n\t\t\t\t? S.INITIAL_DOMAIN_SEPARATOR\n\t\t\t\t: _computeDomainSeparator(S);\n\t}\n\n\t/**\n\t * @dev Calculates and returns the domain separator to be used in any\n\t * permit functions for the strategies {permit} calls.\n\t *\n\t * This will be used at the initialization of each new strategies storage.\n\t * It would then be used in the future in the case of any forks in which\n\t * the current chain id is not the same as the original.\n\t *\n\t */\n\tfunction _computeDomainSeparator(\n\t\tStrategyData storage S\n\t) internal view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tkeccak256(\n\t\t\t\t\t\t\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\t\t\t\t\t),\n\t\t\t\t\tkeccak256(bytes(S.name)),\n\t\t\t\t\tkeccak256(bytes(API_VERSION)),\n\t\t\t\t\tblock.chainid,\n\t\t\t\t\taddress(this)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/*//////////////////////////////////////////////////////////////\n                            DEPLOYMENT\n    //////////////////////////////////////////////////////////////*/\n\n\t/**\n\t * @dev On contract creation we set `asset` for this contract to address(1).\n\t * This prevents it from ever being initialized in the future.\n\t * @param _factory Address of the factory of the same version for protocol fees.\n\t */\n\tconstructor(address _factory) {\n\t\tFACTORY = _factory;\n\t\t_strategyStorage().asset = ERC20(address(0));\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}